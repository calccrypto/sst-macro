<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SST/macro: Simple Message API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customthing.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SST/macro
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Simple Message API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_sstmsgapi"></a>
Simple Message API</h1>
<p>For more advanced usage, users may wish to code more directly with SST/macro C++ functions. If coding directly in MPI, you can only send messages as <code>void*</code> arrays. Additionally, MPI only exposes basic send/recv functionality leaving little control over the exact protocol. If using SST/macro to design a code BEFORE the code actually exists, the recommended path is to use the SST/macro~<code>simp</code> API (simple messages). Send/recv calls pass C++ objects rather than <code>void*</code> arrays, allowing data structures to be directly passed between parallel processes. Additionally, simple functions for datagram send, RDMA, and polling are available, allowing the user to experiment directly with HOW a message is sent. The added flexibility of the C++ interface is potentially beneficial for exploring performance tradeoffs when laying out the initial design of a project. In general, the <code>simp</code> API is geared towards asynchronous execution models rather than bulk-synchronous.</p>
<h2><a class="anchor" id="sec_simp_setup"></a>
Initial Setup</h2>
<p>The code for the example can be found in <code>skeletons/sstmsg</code>. To begin, the basic header files must be included.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sstmac/libraries/sstmsg.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesstmac.html">sstmac</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesstmac_1_1sw.html">sstmac::sw</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesstmac_1_1hw.html">sstmac::hw</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#define debug_print(...) std::cout &lt;&lt; sprockit::printf(__VA_ARGS__)</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>sstmsg {</div><div class="line"></div><div class="line">sstmac_register_app(sstmsg);</div></div><!-- fragment --><p> To simplify the use of SST/macro objects, we declare the three major SST/macro namespaces. For debug printing, SST/macro provides a utility function, <code><a class="el" href="namespacesprockit.html#aaaf1619b98e45002bd1b0c6022c29aa0">sprockit::printf</a></code>, that functions exactly like <code>printf</code> but is compatible with C++ output streams (<code>std::cout</code>). To demonstrate slightly more advanced usage, we declare a new application named "sstmsg" using the <code>sstmac_register_app</code> macro.</p>
<p>To create and send messages, we need to create a message class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>test_message :</div><div class="line">    <span class="keyword">public</span> message</div><div class="line">{</div><div class="line">...</div><div class="line">};</div></div><!-- fragment --><p> We must inherit form the <code>message</code> type. Beyond that, the class can be structured however the user wants. In this test case, each message will perform an action for some value.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">compute</a>, request, terminate, data } action_t;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">    *    Number of bytes requested OR</span></div><div class="line"><span class="comment">    *    Number of bytes being sent OR</span></div><div class="line"><span class="comment">    *    Number of microseconds to compute</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keywordtype">int</span> value_;</div><div class="line"></div><div class="line">    action_t action_;</div></div><!-- fragment --><p> The meaning of <code>value</code> depends on the action, being either the number of bytes to send or the number of &mu;s to compute.</p>
<p>SST/macro is built on top of the Boost smart pointers header library for memory management. To simplify reading of the code and shorten type names, we explicitly typedef all pointer types in the class.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classsprockit_1_1refcount__ptr.html">sprockit::refcount_ptr&lt;test_message&gt;</a> ptr;</div></div><!-- fragment --><p>The next part of the code (omitted) implements various constructors. The most important function call to implement is the <code>clone</code> method</p>
<div class="fragment"><div class="line">sst_message*</div><div class="line">clone(MESSAGE_TYPES ty)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    test_message::ptr cln = <span class="keyword">new</span> test_message(value_, action_);</div><div class="line">    message::clone_into(ty, cln);</div><div class="line">    message::clone_into(cln);</div><div class="line">    <span class="keywordflow">return</span> cln;</div><div class="line">}</div></div><!-- fragment --><p> which overrides a virtual function in the parent class. Messages must be cloned for various subtle reasons through the code. To ensure that the <code>message</code> interface is cloned properly, function calls must be made to the parent <code>clone_into</code> method.</p>
<p>Now that we have a class for sending messages, we can create a thread that will poll for incoming messages.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>messenger_thread :</div><div class="line">    <span class="keyword">public</span> sstmsg_thread</div><div class="line">{</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        sstmsg_queue::ptr work_queue_;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="classsprockit_1_1refcount__ptr.html">sprockit::refcount_ptr&lt;messenger_thread&gt;</a> ptr;</div><div class="line"></div><div class="line">        messenger_thread(<span class="keyword">const</span> sstmsg_queue::ptr&amp; queue)</div><div class="line">            : work_queue_(queue)</div><div class="line">        {</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacesstmac.html#a106484b79a4acb433c26ead1423aeabe">run</a>();</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> terminate();</div><div class="line">};</div></div><!-- fragment --><p> As before, the thread object must inherit from a simple message type. Additionally, we will make use of a another type: <code>sstmsg_queue</code> that can be used for managing work queues between threads. Every thread must implement a run method, which will be invoked by the SST/macro operating system.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line"><a class="code" href="namespacesstmac.html#a106484b79a4acb433c26ead1423aeabe">messenger_thread::run</a>()</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> me = sst_rank();</div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        message::ptr msg = sst_poll();</div><div class="line">        test_message::ptr tmsg = <a class="code" href="sprockit_2sprockit_2util_8h.html#aee212ce0392c46881c69e5910e8823ef">safe_cast</a>(test_message, msg);</div><div class="line">        debug_print(<span class="stringliteral">&quot;receiver got message of type %s on %d\n&quot;</span>,</div><div class="line">                    <a class="code" href="namespacesstmac_1_1hw_1_1routing.html#adda9ddafafbb9024a910fecc906178fd">test_message::tostr</a>(tmsg-&gt;action()), me);</div><div class="line">        work_queue_-&gt;put_message(msg);</div><div class="line">        <span class="keywordflow">if</span> (tmsg-&gt;action() == test_message::terminate)</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> In this case, the loop just runs continuously polling for messages. Because of subtleties in discrete event simulation, <code>sst_poll</code> blocks until a message is found. As mentioned in the introduction, non-blocking probe/polls are not really amenable to discrete event simulation. The messenger thread performs no real work and simply places the message received into a work queue.</p>
<p>Now we can skip ahead to the actual <code>main</code> routine.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line">sstmsg_main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    sst_init();</div><div class="line">    <span class="keywordtype">int</span> me = sst_rank();</div><div class="line">    <span class="keywordtype">int</span> nproc = sst_nproc();</div><div class="line">    std::cout &lt;&lt; <a class="code" href="namespacesprockit.html#aaaf1619b98e45002bd1b0c6022c29aa0">sprockit::printf</a>(<span class="stringliteral">&quot;Rank %d starting\n&quot;</span>, me);</div><div class="line"></div><div class="line">    <span class="comment">//spin off a messenger thread</span></div><div class="line">    sstmsg_queue::ptr work_queue = sstmsg_queue::construct();</div><div class="line">    messenger_thread::ptr thr = <span class="keyword">new</span> messenger_thread(work_queue);</div><div class="line">    thr-&gt;start();</div><div class="line"></div><div class="line">    run_work_loop(me, nproc, work_queue);</div><div class="line"></div><div class="line">    thr-&gt;terminate();</div><div class="line">    thr-&gt;join();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <a class="code" href="namespacesprockit.html#aaaf1619b98e45002bd1b0c6022c29aa0">sprockit::printf</a>(<span class="stringliteral">&quot;Rank %d terminating\n&quot;</span>, me);</div><div class="line">    sst_finalize();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> As in MPI, we must call initialize/finalize routines at the beginning and end of main. Additionally, each process is still assigned a process id (rank) and told the total number of ranks. The code first creates a work queue, creates a messenger thread based on that work queue, and then starts the thread running. The start method invokes all the necessary SST/macro operating system routines, shielding the user from details of the discrete event scheduler. Once the messenger thread is running, the main thread enters a work loop.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_work_loop(<span class="keywordtype">int</span> me, <span class="keywordtype">int</span> nproc, <span class="keyword">const</span> sstmsg_queue::ptr&amp; work_queue)</div><div class="line">{</div><div class="line">    <span class="comment">// send out some data requests and some tasks</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=1; t &lt;= max_num_tasks; ++t){</div><div class="line">        <span class="keywordtype">int</span> dst = (me + t) % nproc;</div><div class="line">        sst_send(dst, <span class="keyword">new</span> test_message(1e4, <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">test_message::compute</a>));</div><div class="line">        sst_send(dst, <span class="keyword">new</span> test_message(1e6, test_message::request));</div><div class="line">    }</div></div><!-- fragment --><p> The work loop begins by sending out (in round-robin fashion) compute tasks that take 10^4 &mu; s. Additionally, it sends out data requests for messages of size 1 MB. Once all the tasks and data requests have been sent, the worker thread starts pulling work from the queue.</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (1)</div><div class="line">{</div><div class="line">    message::ptr msg = work_queue-&gt;poll_until_message();</div><div class="line">    test_message::ptr tmsg = <a class="code" href="sprockit_2sprockit_2util_8h.html#aee212ce0392c46881c69e5910e8823ef">safe_cast</a>(test_message, msg);</div><div class="line">    debug_print(<span class="stringliteral">&quot;got work message of type %s on %d\n&quot;</span>,</div><div class="line">                <a class="code" href="namespacesstmac_1_1hw_1_1routing.html#adda9ddafafbb9024a910fecc906178fd">test_message::tostr</a>(tmsg-&gt;action()), me);</div><div class="line">    <span class="keywordflow">switch</span> (tmsg-&gt;action())</div><div class="line">    {</div><div class="line">            ...</div><div class="line">    }</div></div><!-- fragment --><p>Depending on the type of message received, the worker thread will perform various actions. If a compute message is received:</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">test_message::compute</a>:</div><div class="line">    <span class="comment">//compute for x microseconds</span></div><div class="line">    <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">compute</a>(tmsg-&gt;value()*1e-6);</div><div class="line">    ++num_tasks;</div><div class="line">    <span class="keywordflow">if</span> (terminate(num_tasks, num_sends))</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p> The function <code>compute</code> is included by the header files and simulates a thread computing for a given number of seconds (hence the factor of 10^{-6}). The code tracks the number of tasks and number of send requests received. The function <code>terminate</code> checks to see if all the tasks and sends have been completed.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">test_message::compute</a>:</div><div class="line">    <span class="comment">//compute for x microseconds</span></div><div class="line">    <a class="code" href="namespacesumi.html#af3ac02f179b8622b149b7bdd9b10e5df">compute</a>(tmsg-&gt;value()*1e-6);</div><div class="line">    ++num_tasks;</div><div class="line">    <span class="keywordflow">if</span> (terminate(num_tasks, num_sends))</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p> If a request message is received</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> test_message::request:</div><div class="line">    <span class="comment">//send back x bytes of data</span></div><div class="line">    sst_rdma_put(tmsg-&gt;src(), <span class="keyword">new</span> test_message(tmsg-&gt;value()));</div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p> the code responds to the request by performing an RDMA put of <code>tmsg-&gt;value()</code> number of bytes to the requesting node. If an RDMA put completes at the destination, an ack is generated to signal the node that data is now available.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> test_message::rdma_put_ack:</div><div class="line">    ++num_sends;</div><div class="line">    <span class="keywordflow">if</span> (terminate(num_tasks, num_sends))</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p> Finally, a terminate message might be sent, causing the thread to quit the work loop.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> test_message::terminate:</div><div class="line">    <span class="keywordflow">return</span>;</div></div><!-- fragment --><p>This example shows usage for a very simple asynchronous execution model. Although the code cannot be compiled and actually run on an HPC machine the way an MPI C code can, the C++ interface provides greater flexibility and potentially makes performance experiments easier. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
