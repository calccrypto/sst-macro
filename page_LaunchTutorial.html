<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SST/macro: Launching, Allocation, and Indexing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customthing.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SST/macro
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Launching, Allocation, and Indexing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_tutorial_launchetc"></a>
Launching, Allocation, and Indexing</h1>
<h2><a class="anchor" id="subsec_tutorial_launch"></a>
Launch Commands</h2>
<p>Just as jobs must be launched on a shared supercomputer using Slurm or aprun, SST/macro requires the user to specify a launch command for the application. Currently, we encourage the user to use aprun from Cray, for which documentation can easily be found online. In the parameter file you specify, e.g.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_app1 = user_mpiapp_cxx</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;launch_app1_cmd = aprun -n 8 -N 2</div></div><!-- fragment --><p> which launches an external user C++ application with eight ranks and two ranks per node. The aprun command has many command line options (see online documentation), some of which may be supported in future versions of SST/macro. In particular, we are in the process of adding support for thread affinity, OpenMP thread allocation, and NUMA containment flags. Most flags, if included, will simply be ignored.</p>
<h2><a class="anchor" id="subsec_tutorial_allocation"></a>
Allocation Schemes</h2>
<p>In order for a job to launch, it must first allocate nodes to run on. Here we choose a simple 2D torus</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;topology_name = torus</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;topology_geometry = 3 3</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;network_nodes_per_switch = 1</div></div><!-- fragment --><p> which has 9 nodes arranged in a 3x3 mesh. For the launch command <code>aprun -n 8 -N 2</code>, we must allocate 4 compute nodes from the pool of 9. Our first option is to specify the first available allocation scheme (Figure 8)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_allocation = first_available</div></div><!-- fragment --><p> <br />
</p>
<div class="image">
<img src="firstavailable.png" alt="firstavailable.png"/>
</div>
<p> <b>Figure 8:</b> First available Allocation of 4 Compute Codes on a 3x3 2D Torus</p>
<p><br />
<br />
 In first available, the allocator simply loops through the list of available nodes as they are numbered by the topology object. In the case of a 2D torus, the topology numbers by looping through columns in a row. In general, first available will give a contiguous allocation, but it won't necessarily be ideally structured.</p>
<p>To give more structure to the allocation, a Cartesian allocator can be used (Figure 9).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_allocation = cartesian</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cart_launch_sizes = 2 2</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cart_launch_offsets = 0 0</div></div><!-- fragment --><p> <br />
</p>
<div class="image">
<img src="cartesian.png" alt="cartesian.png"/>
</div>
<p> <b>Figure 9:</b> Cartesian Allocation of 4 Compute Codes on a 3x3 2D Torus</p>
<p><br />
<br />
 Rather than just looping through the list of available nodes, we explicitly allocate a 2x2 block from the torus. If testing how "topology agnostic'' your application is, you can also choose a random allocation.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_allocation = random</div></div><!-- fragment --><p> <br />
</p>
<div class="image">
<img src="random.png" alt="random.png"/>
</div>
<p> <b>Figure 10:</b> Random Allocation of 4 Compute Codes on a 3x3 2D Torus</p>
<p><br />
<br />
</p>
<p>In many use cases, the number of allocated nodes equals the total number of nodes in the machine. In this case, all allocation strategies allocate the same <em>set</em> of nodes, i.e. the whole machine. However, results may still differ slightly since the allocation strategies still assign an initial numbering of the node, which means a random allocation will give different results from Cartesian and first available.</p>
<h3><a class="anchor" id="subsec_tutorial_indexing"></a>
Indexing Schemes</h3>
<p>Once nodes are allocated, the MPI ranks (or equivalent) must be assigned to physical nodes, i.e. indexed. The simplest strategies are block and round-robin. If only running one MPI rank per node, the two strategies are equivalent, indexing MPI ranks in the order received from the allocation list. If running multiple MPI ranks per node, block indexing tries to keep consecutive MPI ranks on the same node (Figure 11).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_indexing = block</div></div><!-- fragment --><p> <br />
</p>
<div class="image">
<img src="block.png" alt="block.png"/>
</div>
<p> <b>Figure 11:</b> Block Indexing of 8 MPI Ranks on 4 Compute Nodes</p>
<p><br />
<br />
 In contrast, round-robin spreads out MPI ranks by assigning consecutive MPI ranks on different nodes (Figure 12).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_indexing = round_robin</div></div><!-- fragment --><p> <br />
</p>
<div class="image">
<img src="roundrobin.png" alt="roundrobin.png"/>
</div>
<p> <b>Figure 12:</b> Round-Robin Indexing of 8 MPI Ranks on 4 Compute Nodes</p>
<p><br />
<br />
 Finally, one may also choose</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;launch_indexing = random</div></div><!-- fragment --><p> Random allocation with random indexing is somewhat redundant. Random allocation with block indexing is <em>not</em> similar to Cartesian allocation with random indexing. Random indexing on a Cartesian allocation still gives a contiguous block of nodes, even if consecutive MPI ranks are scattered around. A random allocation (unless allocating the whole machine) will not give a contiguous set of nodes. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
