#!/usr/bin/env python2

import sys
import signal
import time
import os
import commands
import subprocess
import re

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

TIME_DELTA_TOO_BIG = 0.2
TIME_PERCENT_TOO_BIG = 0.03

verbose = 0
debugger = None
try: verbose = int(os.environ["VERBOSE"])
except: pass
try: debugger = os.environ["DEBUGGER"]
except: pass
timeout = int(sys.argv[1])
srcdir = sys.argv[2]
outputFile = sys.argv[3]
tmpFile = outputFile.replace("chk", "tmp")
condition = sys.argv[4]
EXE_START = 5
exe = sys.argv[EXE_START]
args = " ".join(map(lambda x: '"%s"' % x, sys.argv[6:]))

if not os.path.isdir(srcdir):
  sys.exit("runtest received %s instead of a valid srcdir" % srcdir)

if not os.path.isfile(exe) or not os.access(exe, os.X_OK):
  sys.exit("runtest received invalid exe %s" % exe)

signalBitmask = (1<<7)-1
rcBitmask = (1<<15)-1

IGNORE = 0
TIME_POINT = 1
FINAL_TIME = 2
TEXT_LINE = 3
CORE_TIME = 4

time_point_regexp = re.compile("T\s*=\s*(\d+[.]\d+)")
final_time_regexp = re.compile("[Rr]untime.*?(\d+[.]\d+)(.*)")

def parseLine(line):
  if "WARNING:" in line or "Maximum bad" in line:
    return IGNORE, None

  if "Event queue empty" in line:
    return CORE_TIME, None

  match = time_point_regexp.search(line)
  if match:
    return TIME_POINT, float(match.groups()[0])

  if "untime" in line:
    match = final_time_regexp.search(line)
    time, units = match.groups()
    units = units.strip().lower()
    time = float(time)
    if units == "ms":
      time /= 1e3

    if match:
      return FINAL_TIME, time

  return TEXT_LINE, line

class SimOutput:
  def __init__(self):
    self.lines = {}
    self.times = []
    self.finalTime = -1
    self.integratedCore = False

def parseFile(fname):
  lines = open(fname).read().splitlines()
  sim = SimOutput()
  lineNo = 0
  for line in lines:
    line = line.strip()
    if not line:
      continue
    lineType, value = parseLine(line)
    if lineType == TEXT_LINE:
      sim.lines[value] = lineNo
    elif lineType == TIME_POINT:
      sim.times.append(value)
    elif lineType == FINAL_TIME:
      sim.finalTime = value
    elif lineType == CORE_TIME:
      sim.integratedCore = True
    elif lineType == IGNORE:
      pass
    else:
      sys.exit("Got invalid line type %d in parseFile" % lineType)
    lineNo += 1
  return sim

def checkTime(refTime, chkTime):
  if refTime < 0:
    return "REF did not contain a total runtime"
  if chkTime < 0:
    return "CHK did not contain a total runtime"
  delta = abs(refTime - chkTime)
  percent = delta / refTime
  if delta > TIME_DELTA_TOO_BIG and percent > TIME_PERCENT_TOO_BIG:
    return "REF time %f differs by too much from CHK time %f" % (refTime, chkTime)
  return None

def checkOutput(srcdir, tmpfile, condition):
  splitter = condition.split("=")
  condType = "all"
  condition = splitter[-1]
  if len(splitter) == 2:
    condType = splitter[0]
  elif splitter[0] == "notime":
    condType = "notime"
  elif len(splitter) > 2:
    sys.exit("invalid check condition %s for %s" % (condition, tmpfile))

  if condType == "text":
    chkText = open(tmpfile).read()
    if condition in chkText:
      return None #no problems
    else:
      return "Could not find reference string %s in file" % condition

  refFile = os.path.join(srcdir, "tests", "reference", tmpfile.replace("tmp","ref"))
  refSim = parseFile(refFile)
  chkSim = parseFile(tmpfile)


  if not len(refSim.times) == len(chkSim.times):
    return "REF has %d time points, but CHK has %d time points" % (len(refSim.times), len(chkSim.times))

  for i in range(len(refSim.times)):
    errorMsg = checkTime(refSim.times[i], chkSim.times[i])
    if errorMsg:
      return errorMsg

  if chkSim.integratedCore:
    pass
  elif not condType == "notime":
    timeChecker = eval("lambda t: %s" % condition)
    if not timeChecker(chkSim.finalTime):
      return "t=%f failed time check %s" % (chkSim.finalTime, condition)
    errorMsg = checkTime(refSim.finalTime, chkSim.finalTime)
    if errorMsg:
      return errorMsg

  for line in refSim.lines:
    if not chkSim.lines.has_key(line):
      return "Line %s missing from CHK file" % line

  #all good
  return None


def handleTerminate(sig, frame):
    sys.exit(0)

def runexe(exe, args, tmpFile):
  errorFile = "%s.ERROR" % tmpFile
  cmd = "%s %s 1>> %s 2>> %s" % (exe, args, tmpFile, errorFile)
  out=open(tmpFile,"w")
  err=open(errorFile,"w")
  if verbose:
    print cmd
  try:
    rc = subprocess.call(sys.argv[EXE_START:], stdout=out, stderr=err)
    out.close()
    err.close()
  except Exception as e:
    print e
    sys.exit(111)
  if rc < 0:
    sig = abs(rc)
    text = "TERMINATED WITH SIGNAL: %d %s" % (sig, tmpFile)
    print bcolors.FAIL, text, bcolors.ENDC
    open(tmpFile,"w").write(text)
    sys.exit(111)
  else:
    sys.exit(rc)

if debugger:
    debugargs = "r " + args
    print "DEBUG ARGS: ", debugargs
    folder, script = os.path.split(exe)
    actualExe = ".libs/%s" % script
    actualExe = os.path.join(folder, actualExe)
    cmd = "%s %s" % (debugger, actualExe)
    os.system(cmd)
    sys.exit(0)

#fork off a child process to run the test
try: exepid = os.fork()
except OSError:
  print bcolors.FAIL, "TEST FORK FAILED"
  sys.exit(111)
if exepid == 0:
  runexe(exe, args, tmpFile)
  sys.exit()

try: waiterpid = os.fork()
except OSError:
  print bcolors.FAIL, "TEST FORK FAILED"
  sys.exit(111)
if waiterpid == 0:
    signal.signal(signal.SIGTERM, handleTerminate)
    time.sleep(timeout)
    try: os.kill(exepid, signal.SIGKILL)
    except OSError: pass
else:
    pid, bits = os.waitpid(exepid,0)
    os.kill(waiterpid, signal.SIGTERM)
    rc = (bits & rcBitmask) >> 8
    sig = bits & signalBitmask
    if sig:
        if sig == signal.SIGKILL:
            text = "TIMEOUT: %s" % outputFile
            print bcolors.FAIL, text, bcolors.ENDC
            open(outputFile,"w").write(text)
        else:
          text = "TERMINATED WITH SIGNAL %d" % sig
          open(outputFile,"w").write(text)
        try: os.kill(exepid, signal.SIGTERM)
        except OSError: pass
    elif rc == 0:
        errorMsg = checkOutput(srcdir, tmpFile, condition)
        text = None
        if errorMsg:
          text = "FAILED: %s: %s" % (outputFile, errorMsg)
          print bcolors.FAIL, text, bcolors.ENDC
        else:
          text = "PASSED: %s" % outputFile
          print bcolors.OKGREEN, text, bcolors.ENDC
        open(outputFile,"w").write(text)
    elif rc == 111:
        text = "TERMINATED WITH UNKNOWN ERROR"
        open(outputFile,"w").write(text)
    else:
        text = "ERROR/EXCEPTION: %s" % outputFile
        print bcolors.FAIL, text, bcolors.ENDC
        open(outputFile,"w").write(text)
